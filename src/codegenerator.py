import keyword
import logging
import os
import textwrap
import traceback
import urllib

from OpenGL._bytes import as_str, unicode, as_unicode
import xmlreg

HERE = os.path.join(os.path.dirname(__file__))
log = logging.getLogger(__name__)
AUTOGENERATION_SENTINEL = """# DO NOT EDIT above the line "END AUTOGENERATED SECTION" below!"""
AUTOGENERATION_SENTINEL_END = """# END AUTOGENERATED SECTION"""


def name_to_path_minus_gl(name):
    return "/".join(name.split("_", 2)[1:])


def prefix_split(name):
    return name.split("_", 2)[1:]


def indent(text, indent="\t"):
    return "\n".join([f"{indent}{line}" for line in text.splitlines()])


class Generator(object):  # generates functions
    target_directory = os.path.join(HERE, "..", "OpenGL")
    raw_target_directory = os.path.join(HERE, "..", "OpenGL", "raw")
    prefix = "GL"
    dll = "_p.PLATFORM.GL"
    include_overviews = True

    def __init__(self, registry, type_translator):
        self.registry = registry
        self.type_translator = type_translator

    def module(self, module):
        if hasattr(module, "apis"):
            for api in module.apis:
                if api != "glcore":
                    gen = ModuleGenerator(module, self, api)
                    gen.generate()
        else:
            gen = ModuleGenerator(module, self)
            gen.generate()
        return gen

    GLGET_PARAM_GROUPS = ["GetPName", "GetPointervPName"]
    # MUTED: "MaterialParameter", "PixelMap", "LightParameter", "GetPixelMap",
    # "GetMapQuery", "TextureEnvParameter", "TextureGenParameter"

    @staticmethod
    def make_gl_get(prefix, elements):
        out = [""""glGet * auto-generation of output arrays (DO NOT EDIT, AUTOGENERATED)""",
               "try:",
               f"    from OpenGL.raw.{prefix}._lookupint import LookupInt as _L",
               "except ImportError:",
               "    def _L(*args):",
               '        raise RuntimeError("Need to define a lookupint for this api")',
               "_glget_size_mapping = _m = {}",
               f"{elements}"]
        return "\n".join(out)

    def group_sizes(self):
        """Generate a group-sizes data-table for the given group-name"""  # what?
        result = []
        for enum_name, size in sorted(self.glGetSizes.items(), key=lambda x: (bool(x[1]), x[0])):
            value = self.registry.enumeration_set.get(enum_name)
            size = [x for x in size if x]
            comment = ""
            if not size:
                size = "TODO"
                comment = "# "
            else:
                size = "".join(size)
            if value is None:
                # common in cases where GL and GLES constants are updated together...
                log.debug(f"Unrecognized constant: {enum_name} in GLGet section")
            else:
                value = value.value
                result.append(f"{comment}_m[{value}] = {size} # {enum_name}")
        elements = "\n".join(result)
        prefix = self.prefix
        return self.make_gl_get(prefix, elements)

    def enum(self, enum):
        comment = ""
        try:
            int(enum.value, 0)  # convert to base 0 int? why?
        except ValueError:
            comment = "# "
        return f"{comment}{enum.name} = _C({enum.name}, {enum.value})"

    def safe_name(self, name):
        if keyword.iskeyword(name):
            return name + "_"
        return name

    def function(self, function):
        """Produce a declaration for this function in ctypes format"""  # feeds into raw?
        return_type = self.type_translator(function.return_type)
        if return_type == "arrays.GLbyteArray":
            return_type = "ctypes.c_char_p"
        if function.argument_types:
            argument_types = ", ".join([self.type_translator(x) for x in function.argument_types])
        else:
            argument_types = ""
        if function.argument_names:
            argument_names = ", ".join([self.safe_name(n) for n in function.argument_names])
        else:
            argument_names = ""
        arguments = ", ".join([f"{t} {self.safe_name(n)}" for t, n in zip(function.argument_types, function.argument_names)])

        name = function.name
        if return_type.strip() in ("_cs.GLvoid", "_cs.void", "void"):
            return_type = pyReturn = "None"
        else:
            pyReturn = function.return_type

        doc = f"{name}({arguments}) -> {pyReturn}"
        log.info(f"{doc}")
        formatted = f"""@_f
    @_p.types({return_type}, {argument_types})
    def {name}({argument_names}): pass"""  # add docstring? type hints?
        return formatted

    _glGetSizes = None

    @property
    def glGetSizes(self):
        if self._glGetSizes is None:
            self._glGetSizes = self.loadGLGetSizes()
        return self._glGetSizes

    def loadGLGetSizes(self):
        """Load manually-generated table of glGet* sizes"""
        table = {}
        try:
            lines = [line.split("\t") for line in open(os.path.join(HERE, "glgetsizes.csv")).read().splitlines()]
        except IOError:
            pass
        else:
            for line in lines:
                if line and line[0]:
                    value = [v for v in [line.strip('"') for v in line[1:]] if v]
                    if value:
                        table[line[0].strip('"').strip()] = value  # there must be a better way
        # now make sure everything registered in the xml file is present...
        output_group_names = {}
        for function in self.registry.command_set.values():
            output_group_names.update(function.output_groups)
        for output_group in output_group_names.keys():
            log.debug(f"Output parameter group: {output_group}")
            for name in self.registry.enum_groups.get(output_group, []):
                if name not in table:
                    log.info(f"New {output_group} value: {name}")
                    table[name] = ""
        return table

    def saveGLGetSizes(self):
        """Save out sorted list of glGet sizes to disk"""
        items = self.glGetSizes.items()
        items.sort()
        data = "\n".join([f"{key}    {'    '.join(value)}" for key, value in items])
        open(os.path.join(HERE, "glgetsizes.csv"), "w").write(data)
        # oh boy I sure hope garbage collection doesn"t mind closing this


class ModuleGenerator(object):
    ROOT_EXTENSION_SOURCE = "https://www.opengl.org/registry/specs/"

    def raw_module(self):
        out = "\n".join(['"""Autogenerated by xml_generate script, do not edit!"',
                         "import ctypes",
                         "",
                         "from OpenGL import arrays",
                         "from OpenGL import platform as _p",
                         "# Code generation uses this:",
                         f"from OpenGL.raw.{self.prefix} import _types as _cs",
                         "# End users want this:",
                         f"from OpenGL.raw.{self.prefix}._types import *",  # we don't want star imports
                         f"from OpenGL.raw.{self.prefix} import _errors",
                         "from OpenGL.constant import Constant as _C",
                         f"{self.extra_imports}",
                         f"_EXTENSION_NAME = {self.constant_module}",
                         "def _f(function):",
                         f"    return _p.createFunction(function, {self.dll}, " +
                         f"{self.constant_module}, error_checker=_errors._error_checker)",
                         f"{self.constants}",
                         f"{self.declarations}"])
        return out

    dll = "_p.PLATFORM.GL"

    def __init__(self, registry, overall, api=None):
        self.registry = registry
        self.overall = overall
        name = registry.name
        if name in ("GL_ES_VERSION_3_1", "GL_ES_VERSION_3_0"):
            api = "gles3"
            name = "GLES3"+name[5:]
        if api:
            self.prefix = api.upper()
        else:
            if hasattr(self.registry, "api"):
                self.prefix = self.registry.api.upper()
            else:
                self.prefix = name.split("_")[0]
        name = name.split("_", 1)[1]

        try:
            self.owner, self.module = name.split("_", 1)
            self.sentinelConstant = f"{self.owner}_{self.module}"
        except ValueError:
            if name.endswith("SGIX"):
                self.prefix = "GL"
                self.owner = "SGIX"
                self.module = name[3:-4]
                self.sentinelConstant = f"{self.module}{self.owner}"
            else:
                log.error(f"""Unable to parse module name: {name}""")
                raise

        self.dll = f"_p.PLATFORM.{self.prefix}"
        if self.module[0].isdigit():
            self.module = f"{self.prefix}_{self.module}"
        if self.module == "async":
            self.module = "async_"
        self.camelModule = "".join([x.title() for x in self.module.split("_")])
        self.rawModule = self.module

        self.rawOwner = self.owner
        while self.owner and self.owner[0].isdigit():
            self.owner = self.owner[1:]
        self.rawPathName = os.path.join(self.overall.raw_target_directory, self.prefix, self.owner, self.module + ".py")
        self.pathName = os.path.join(self.overall.target_directory, self.prefix, self.owner, self.module + ".py")

        self.constant_module = f"{self.prefix}_{self.owner}_{self.rawModule}"
        specification = self.getSpecification()
        self.constantsFromSpec()
        self.overview = ""
        if self.overall.include_overviews:
            for title, section in specification.blocks(specification.source):
                if title.startswith("Overview"):
                    if isinstance(section, bytes):
                        section = section.decode("latin-1")  # seems to not be utf; at least in some cases
                    s = indent(as_unicode(as_str(section).replace("\xd4", "O").replace("\xd5", "O"))
                               .encode("ascii", "ignore").decode("ascii", "ignore"))
                    self.overview = f"Overview (from the spec)\n{s}\n\n"
                    break

    def __getitem__(self, key):
        try:
            return getattr(self, key)
        except AttributeError:
            raise KeyError(key)

    def __getattr__(self, key):
        if key not in ("registry",):
            return getattr(self.registry, key)

    @property
    def extra_imports(self):
        if self.name == "GL_VERSION_1_1":
            # spec files have not properly separated out these two...
            return "# Spec mixes constants from 1.0 and 1.1\nfrom OpenGL.raw.GL.VERSION.GL_1_0 import *"
        return ""

    def constantsFromSpec(self, spec=None):
        """Examine spec text looking for new constants..."""
        spec = spec or self.getSpecification()
        if spec.source:
            table = self.overall.glGetSizes
            extras = spec.glGetConstants()
            changed = False
            for key, value in extras.items():
                if key not in table:
                    try:
                        value = int(value, 16)
                    except ValueError:
                        continue
                    short_key = "_".join(key.split("_")[:-1])
                    if short_key in table:
                        short_def = self.overall.registry.enumeration_set.get(short_key)
                        if short_def and int(short_def.value, 16) == value:
                            key = short_def.name
                    if key not in table:
                        table[key] = ["(1,)", f"#TODO Review {self.specFile()}"]
                        changed = True
            if changed:
                self.overall.saveGLGetSizes()

    def shouldReplace(self):
        """Should we replace the given filename?"""
        filename = self.pathName
        if not os.path.isfile(filename):
            return True
        else:
            hasLines = 0
            for line in open(filename):
                if line.strip() == AUTOGENERATION_SENTINEL_END.strip():
                    return True
                hasLines = 1
            if not hasLines:
                return True
            log.warning(f"Not replacing {filename} (no AUTOGENERATION_SENTINEL_END found)")
        return False

    @property
    def output_wrapping(self):
        """Generate output wrapping statements for our various functions"""
        try:
            statements = []
            for function in self.registry.commands():
                dependencies = function.size_dependencies
                if dependencies:  # temporarily just do single-output functions...
                    base = []
                    for param, dependency in sorted(dependencies.items()):
                        param = as_str(param)
                        if isinstance(dependency, xmlreg.Output):
                            statements.append(f"# {function.name}.{param} is OUTPUT without known output size")
                        if isinstance(dependency, xmlreg.Staticsize):
                            base.append(f".setOutput({param}, size=({dependency},), orPassIn=True)")
                        elif isinstance(dependency, xmlreg.Dynamicsize):
                            base.append(f".setOutput({param}, size=lambda x:(x,), pnameArg={dependency}, orPassIn=True)")
                        elif isinstance(dependency, xmlreg.Multiple):
                            pname, multiple = dependency
                            base.append(f".setOutput({param}, size=lambda x:(x, {multiple}), pnameArg={pname}, orPassIn=True)")
                        elif isinstance(dependency, xmlreg.Compsize):
                            if len(dependency) == 1:
                                pname = dependency[0]
                                base.append(f".setOutput({param}, size=_glgets._glget_size_mapping, "
                                            "pnameArg={pname}, orPassIn=True)")
                            else:
                                statements.append(f"# OUTPUT {function.name}.{param} COMPSIZE({', '.join(dependency)})")
                        elif isinstance(dependency, xmlreg.StaticInput):
                            base.append(f".setInputArraySize({param}, {dependency})")
                        elif isinstance(dependency, (xmlreg.DynamicInput, xmlreg.MultipleInput, xmlreg.Input)):
                            if dependency is None:
                                continue
                            statements.append(f"# INPUT {function.name}.{param} size not checked against {dependency}")
                            base.append(f".setInputArraySize({param}, None)")
                    if base:
                        base.insert(0, f"{function.name.lstrip('gl')} = wrapper.wrapper({function.name})")
                        # ^ rip that C namespace nonsese off and use the python namespace
                        # - glVertex3d -> gl.Vertex3d
                        statements.append("".join(base))
            return "\n".join(statements)
        except Exception:
            traceback.print_exc()
            import pdb
            pdb.set_trace()

    def get_constants(self):
        functions = self.registry.enums()
        functions.sort(key=lambda x: x.name)
        return functions

    @property
    def init_function(self):
        return "\n".join([f"def glInit{self.camelModule}{self.owner}():",
                          "Return boolean indicating whether this extension is available",
                          "from OpenGL import extensions",
                          "return extensions.hasGLExtension(_EXTENSION_NAME)"])

    @property
    def constants(self):
        result = []
        try:
            for function in self.get_constants():
                result.append(self.overall.enum(function))
            return "\n".join(result)
        except Exception:
            traceback.print_exc()
            raise

    @property
    def declarations(self):
        functions = self.registry.commands()
        functions.sort(key=lambda x: x.name)
        result = []
        for function in functions:
            result.append(self.overall.function(function))
        return "\n".join(result)
    EXTENSION_BASE = os.path.join(HERE, "khronosapi", "extensions")

    def specFile(self):
        """Lookup the specification file for our extension"""
        prefix, name = prefix_split(self.name)
        specFile = os.path.join(self.EXTENSION_BASE, prefix, f"{prefix}_{name}.txt")
        return specFile

    def getSpecification(self):
        """Retrieve our specification document...

        Retrieves the .txt file which defines this specification,
        allowing us to review the document locally in order to provide
        a reasonable wrapping of it..."""
        if self.registry.feature:
            return Specification("")
        specFile = self.specFile()
        if os.path.exists(specFile):
            data = open(specFile, "rb").read()
            return Specification(data)
        else:
            log.info(f"No spec-file in {specFile}")
            return Specification("")

    def generate(self):
        for target in (self.rawPathName, self.pathName):
            directory = os.path.dirname(target)
            if not os.path.exists(directory):
                log.warning(f"Creating target directory: {directory}")
                os.makedirs(directory)
            if not os.path.isfile(os.path.join(directory, "__init__.py")):
                open(os.path.join(directory, "__init__.py"), "w").write(""""OpenGL Extensions""")

        directory = os.path.dirname(self.rawPathName)
        current = ""
        toWrite = self.raw_module()
        try:
            current = open(self.rawPathName, "r").read()
        except Exception:
            pass
        if current.strip() != toWrite.strip():
            fh = open(self.rawPathName, "w")
            fh.write(toWrite)
            fh.close()
        if isinstance(self.registry, xmlreg.Feature):
            # this is a core feature...
            target = os.path.join(self.overall.raw_target_directory, self.prefix, "_glgets.py")
            open(target, "w").write(self.overall.group_sizes())
        if self.shouldReplace():
            # now the final module with any included custom code...
            toWrite = "\n".join([f'"""OpenGL extension {self.owner}.{self.module}',
                                 "This module customises the behaviour of the",
                                 f"OpenGL.raw.{self.prefix}.{self.owner}.{self.module} to provide a more Python-friendly API",
                                 f"{self.overview}The official definition of this extension is available here:",
                                 f'{self.ROOT_EXTENSION_SOURCE}{self.owner}/{self.module}.txt"""',  # end docstring
                                 "import ctypes",
                                 "",  # break a line between builtins & local imports
                                 "from OpenGL import platform, constant, arrays",
                                 "from OpenGL import extensions, wrapper",
                                 f"from OpenGL.raw.{self.prefix} import _types, _glgets",
                                 f"from OpenGL.raw.{self.prefix}.{self.owner}.{self.module} import *",
                                 f"from OpenGL.raw.{self.prefix}.{self.owner}.{self.module} import _EXTENSION_NAME",
                                 "",
                                 "",
                                 f"{self.init_function}",
                                 f"{self.output_wrapping}"])
            current = ""
            try:
                current = open(self.pathName, "r").read()
            except Exception:
                pass
            else:
                found = current.rfind("\n"+AUTOGENERATION_SENTINEL_END)
                if found >= -1:
                    if current[:found].strip() == toWrite.strip():
                        # we aren"t going to change anything...
                        return False
                    found += len("\n" + AUTOGENERATION_SENTINEL_END)
                    current = current[found:]
                else:
                    current = ""
            try:
                fh = open(self.pathName, "w")
            except IOError as err:
                log.warning(f"Unable to create module for {self.name} {err}")
                return False
            else:
                fh.write(toWrite)
                fh.write(AUTOGENERATION_SENTINEL_END)
                fh.write(current)
                fh.close()
                return True
        return False


class Specification(object):
    """Parser for parsing OpenGL specifications for interesting information"""
    def __init__(self, source):
        """Store the source text for the specification"""
        if isinstance(source, bytes):
            try:
                self.source = source.decode("utf-8")
            except UnicodeDecodeError:
                self.source = source.decode("latin-1")
        else:
            self.source = source
        assert isinstance(self.source, unicode)

    def blocks(self, data):
        """Retrieve the set of all blocks"""
        data = data.splitlines()
        title = []
        block = []
        for line in data:
            if line and line.lstrip() == line:
                if block:
                    yield "\n".join(title), textwrap.dedent("\n".join(block))
                    title = []
                    block = []
                title.append(line)
            else:
                block.append(line)
        if block:
            yield "\n".join(title), textwrap.dedent("\n".join(block))

    def constantBlocks(self):
        """Retrieve the set of constant blocks"""
        for title, block in self.blocks(self.source):
            if title and title.startswith("New Tokens"):
                yield block

    def glGetConstants(self):
        """Retrieve the set of constants which pass to glGet* functions"""
        table = {}
        for block in self.constantBlocks():
            for title, section in self.blocks(block):
                for possible in ("GetBooleanv", "GetIntegerv", "<pname> of Get", "<pname> parameter of Get"):
                    if possible in title:
                        for line in section.splitlines():
                            line = line.strip().split()
                            if len(line) == 2:
                                constant, value = line
                                constant = constant.strip(":")
                                table[f"GL_{constant}"] = value
                        break
        return table


def download(url):
    """Download the given url, informing the user of what we"re doing"""
    log.info(f"Download: {url}")
    file = urllib.urlopen(url)
    return file.read()
